---
title: "AN√ÅLISE DISCRIMINANTE"
lang: pt-BR
author:
  - name: Marcus Antonio Cardoso Ramalho
    email: marcus.ramalho@coppead.ufrj.br
    affiliations:
      - name: COPPEAD - UNIVERSIDADE FEDERAL DO RIO DE JANEIRO
        address: Rua Pascoal Lemme, 355
        city: Rio de Janeiro
        state: RJ
        postal-code: 21941-918
  - name: Claudia Regina da Costa de Souza
  - name: Ben Hur Correia
date: today

---

```{r}
#| include: false
#| echo: true
#| message: false
#| warning: false

# Carregando os pacotes necess√°rios
if (!require("MASS")) install.packages("MASS")
if (!require("klaR")) install.packages("klaR")
if (!require("car")) install.packages("car")
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("dplyr")) install.packages("dplyr")
if (!require("corrplot")) install.packages("corrplot")
if (!require("caret")) install.packages("caret")
if (!require("skimr")) install.packages("skimr")
if (!require("MVN")) install.packages("MVN")
if (!require("biotools")) install.packages("biotools")
if (!require("GGally")) install.packages("GGally")
if (!require("nnet")) install.packages("nnet")
if (!require("pROC")) install.packages("pROC")
if (!require("tidyr")) install.packages("tidyr")
if (!require("readr")) install.packages("readr")
if (!require("haven")) install.packages("haven")
if (!require("gridExtra")) install.packages("gridExtra")
if (!require("reshape2")) install.packages("reshape2")
if (!require("viridis")) install.packages("viridis")
if (!require("plotly")) install.packages("plotly")
if (!require("RColorBrewer")) install.packages("RColorBrewer")

```

```{r}
#| echo: true
#| message: false
#| warning: false

library(MASS)
library(klaR)
library(car)
library(ggplot2)
library(dplyr)
library(corrplot)
library(caret)
library(skimr)
library(MVN)
library(biotools)
library(GGally)
library(nnet)
library(pROC)
library(tidyr)
library(readr)
library(haven)
library(gridExtra)
library(reshape2)
library(viridis)
library(plotly)
library(RColorBrewer)
```

## An√°lise Discriminante - Exemplo HBAT


### Reprodu√ß√£o do Exemplo de Hair et al. - Dataset HBAT

Nesta se√ß√£o, reproduziremos a an√°lise discriminante apresentada no livro Hair et al., utilizando o dataset HBAT para classificar clientes em tr√™s grupos baseados no tempo de relacionamento com a empresa.


O **HBAT** √© um dataset educacional fict√≠cio amplamente utilizado no livro cl√°ssico "Multivariate Data Analysis" de Joseph Hair et al., representando uma empresa de distribui√ß√£o industrial. O dataset cont√©m **100 observa√ß√µes** de clientes classificados em tr√™s grupos baseados no tempo de relacionamento: **Grupo 1** (menos de 1 ano), **Grupo 2** (1 a 5 anos) e **Grupo 3** (mais de 5 anos). As vari√°veis incluem a **vari√°vel dependente X1** (Customer Type) e **13 vari√°veis independentes** (X6-X18) que medem percep√ß√µes dos clientes sobre diferentes aspectos da empresa, como qualidade do produto (X6), atividades de e-commerce (X7), suporte t√©cnico (X8), resolu√ß√£o de reclama√ß√µes (X9), propaganda (X10), linha de produtos (X11), imagem da for√ßa de vendas (X12), pre√ßos competitivos (X13), garantia e reclama√ß√µes (X14), novos produtos (X15), pedidos e faturamento (X16), flexibilidade de pre√ßos (X17) e velocidade de entrega (X18). Todas as vari√°veis independentes utilizam uma **escala de 0-10**, facilitando compara√ß√µes e interpreta√ß√µes. Este dataset √© ideal para demonstrar t√©cnicas de an√°lise multivariada, especialmente an√°lise discriminante, pois oferece um contexto empresarial realista com dados limpos e estruturados, permitindo focar na aplica√ß√£o das t√©cnicas estat√≠sticas sem se preocupar com problemas complexos de qualidade de dados t√≠picos de datasets reais.

### Est√°gio 1: Objetivos da An√°lise Discriminante

O objetivo √© identificar as caracter√≠sticas perceptuais que distinguem clientes baseados no tempo de relacionamento:
- **Grupo 1**: Menos de 1 ano
- **Grupo 2**: De 1 a 5 anos  
- **Grupo 3**: Mais de 5 anos

#### Carregamento e Inspe√ß√£o dos Dados do arquivo spss

```{r}
# Carregando os dados HBAT
hbat <- haven::read_sav("data/hbat.sav")

glimpse(hbat)

```


```{r}
#| include: false
#| echo: false


# Gr√°fico da distribui√ß√£o da vari√°vel dependente
p_dist_grupos <- ggplot2::ggplot(data.frame(x1 = hbat$x1), ggplot2::aes(x = factor(x1))) +
  ggplot2::geom_bar(fill = "steelblue", alpha = 0.7) +
  ggplot2::geom_text(stat = "count", ggplot2::aes(label = after_stat(count)), 
                     vjust = -0.5, size = 4) +
  ggplot2::labs(title = "Distribui√ß√£o dos Grupos por Tempo de Relacionamento",
                x = "Grupo (1=<1 ano, 2=1-5 anos, 3=>5 anos)",
                y = "Frequ√™ncia") +
  ggplot2::theme_minimal() +
  ggplot2::theme(plot.title = ggplot2::element_text(size = 14, face = "bold"))

print(p_dist_grupos)
```



```{r}
#| include: false
#| echo: false

# Identificando as vari√°veis corretas baseado na estrutura real do dataset
# Primeiro vamos ver quais vari√°veis existem realmente
print("Vari√°veis dispon√≠veis no dataset:")
print(colnames(hbat))

# Verificando se existem vari√°veis que correspondem √†s do exemplo Hair
# Procurando por padr√µes de nomes que possam corresponder a X1, X6-X18
possiveis_vars <- grep("^[Xx][0-9]+", names(hbat), value = TRUE)
print("Poss√≠veis vari√°veis X encontradas:")
print(possiveis_vars)

# Se n√£o encontrar, vamos procurar por outras vari√°veis categ√≥ricas e num√©ricas
cat("\nEstrutura das primeiras 10 vari√°veis:\n")
str(hbat[,1:min(10, ncol(hbat))])
```



```{r}
#| include: false
#| echo: false


# Preparando os dados baseado na estrutura real encontrada
# Vamos adaptar baseado nas vari√°veis que realmente existem

# Primeiro, identificar a vari√°vel dependente (tempo de relacionamento)
# Procurar por vari√°veis categ√≥ricas que possam representar grupos de tempo

# Listar vari√°veis categ√≥ricas
vars_categoricas <- sapply(hbat, function(x) is.factor(x) || length(unique(x)) <= 10)
print("Vari√°veis categ√≥ricas ou com poucos valores √∫nicos:")
print(names(hbat)[vars_categoricas])

# Examinar algumas vari√°veis categ√≥ricas potenciais
for(var in names(hbat)[vars_categoricas][1:min(5, sum(vars_categoricas))]) {
  cat("\nVari√°vel:", var, "\n")
  print(table(hbat[[var]], useNA = "ifany"))
}
```

#### Defini√ß√£o das Vari√°veis do Modelo

Com base na inspe√ß√£o dos dados, identificamos que o dataset HBAT possui exatamente as vari√°veis necess√°rias:
- **x1**: Vari√°vel dependente (Customer Type: 1=Menos de 1 ano, 2=De 1 a 5 anos, 3=Mais de 5 anos)
- **x6-x18**: Vari√°veis independentes (percep√ß√µes sobre a HBAT)

```{r}
#| include: false
#| echo: false
# Agora que sabemos a estrutura, vamos usar as vari√°veis corretas
variavel_dependente <- "x1"  # Customer Type - exatamente o que precisamos
variaveis_independentes <- paste0("x", 6:18)  # x6 a x18 - percep√ß√µes

# Verificando se x1 tem os valores corretos
print(table(hbat$x1, useNA = "ifany"))

# Verificando os labels da vari√°vel x1
if(haven::is.labelled(hbat$x1)) {
  print(haven::as_factor(hbat$x1))
  print(table(haven::as_factor(hbat$x1)))
}
```

**Configura√ß√£o das Vari√°veis:**

- **Vari√°vel dependente**: `r variavel_dependente`
- **Vari√°veis independentes**: `r paste(variaveis_independentes, collapse = ", ")`
- **Total de vari√°veis independentes**: `r length(variaveis_independentes)`

#### Prepara√ß√£o do Dataset Final

```{r}
#| include: false
# Criando dataset limpo com as vari√°veis corretas identificadas
hbat_clean <- hbat %>%
  dplyr::select(dplyr::all_of(c(variavel_dependente, variaveis_independentes))) %>%
  na.omit()

# Converter x1 para fator com os labels corretos do exemplo Hair
hbat_clean <- hbat_clean %>%
  dplyr::mutate(
    X1 = factor(x1, 
                levels = 1:3,
                labels = c("Menos de 1 ano", "De 1 a 5 anos", "Mais de 5 anos"))
  ) %>%
  dplyr::select(-x1)

# Renomear vari√°veis independentes para seguir padr√£o X6-X18 (mai√∫sculas)
nomes_independentes <- paste0("X", 6:18)
names(hbat_clean)[names(hbat_clean) != "X1"] <- nomes_independentes

# Reordenar colunas para X1 ficar primeiro
hbat_clean <- hbat_clean %>%
  dplyr::select(X1, dplyr::everything())

# Atualizar lista de vari√°veis independentes
variaveis_independentes <- nomes_independentes

# Criando dicion√°rio de descri√ß√µes das vari√°veis
descricoes_variaveis <- c(
  "X1" = "Customer Type",
  "X6" = "Product Quality",
  "X7" = "E-Commerce Activities",
  "X8" = "Technical Support",
  "X9" = "Complaint Resolution",
  "X10" = "Advertising",
  "X11" = "Product Line",
  "X12" = "Salesforce Image",
  "X13" = "Competitive Pricing",
  "X14" = "Warranty & Claims",
  "X15" = "New Products",
  "X16" = "Ordering & Billing",
  "X17" = "Price Flexibility",
  "X18" = "Delivery Speed"
)

# Fun√ß√£o para obter descri√ß√£o completa da vari√°vel
obter_descricao <- function(var) {
  if(var %in% names(descricoes_variaveis)) {
    return(descricoes_variaveis[var])
  } else {
    return(var)
  }
}
```

**Resumo da Prepara√ß√£o dos Dados:**

- **Total de observa√ß√µes**: `r nrow(hbat_clean)`
- **Vari√°veis independentes**: `r length(variaveis_independentes)`
- **Grupos identificados**: `r nlevels(hbat_clean$X1)`

**Distribui√ß√£o da Vari√°vel Dependente (X1):**
```{r}
#| echo: false
knitr::kable(table(hbat_clean$X1), col.names = c("Grupo", "Frequ√™ncia"))
```

**Descri√ß√µes das Vari√°veis:**

| C√≥digo | Descri√ß√£o |
|--------|-----------|
| X1 | Customer Type |
| X6 | Product Quality |
| X7 | E-Commerce Activities |
| X8 | Technical Support |
| X9 | Complaint Resolution |
| X10 | Advertising |
| X11 | Product Line |
| X12 | Salesforce Image |
| X13 | Competitive Pricing |
| X14 | Warranty & Claims |
| X15 | New Products |
| X16 | Ordering & Billing |
| X17 | Price Flexibility |
| X18 | Delivery Speed |

### Est√°gio 2: Delineamento da Pesquisa de An√°lise Discriminante

```{r}
# Divis√£o em amostras de an√°lise e valida√ß√£o
set.seed(123)
n_total <- nrow(hbat_clean)
indices_analise <- sample(1:n_total, size = floor(0.6 * n_total))

amostra_analise <- hbat_clean[indices_analise, ]
amostra_validacao <- hbat_clean[-indices_analise, ]

# Verificar balanceamento dos grupos
prop_analise <- table(amostra_analise$X1) / nrow(amostra_analise)
prop_validacao <- table(amostra_validacao$X1) / nrow(amostra_validacao)
```

A an√°lise discriminante requer a divis√£o dos dados em amostras de estima√ß√£o e valida√ß√£o para avaliar adequadamente o desempenho do modelo. Utilizamos uma divis√£o de 60% para an√°lise e 40% para valida√ß√£o.

**Caracter√≠sticas das Amostras:**

- **Amostra de an√°lise**: `r nrow(amostra_analise)` casos
- **Amostra de valida√ß√£o**: `r nrow(amostra_validacao)` casos

**Distribui√ß√£o dos Grupos por Amostra:**

| Grupo | An√°lise (n) | An√°lise (%) | Valida√ß√£o (n) | Valida√ß√£o (%) |
|-------|-------------|-------------|---------------|---------------|
| Menos de 1 ano | `r table(amostra_analise$X1)[1]` | `r round(prop_analise[1] * 100, 1)`% | `r table(amostra_validacao$X1)[1]` | `r round(prop_validacao[1] * 100, 1)`% |
| De 1 a 5 anos | `r table(amostra_analise$X1)[2]` | `r round(prop_analise[2] * 100, 1)`% | `r table(amostra_validacao$X1)[2]` | `r round(prop_validacao[2] * 100, 1)`% |
| Mais de 5 anos | `r table(amostra_analise$X1)[3]` | `r round(prop_analise[3] * 100, 1)`% | `r table(amostra_validacao$X1)[3]` | `r round(prop_validacao[3] * 100, 1)`% |

### Est√°gio 3: Pressupostos da An√°lise Discriminante

#### 3.1 Normalidade Multivariada

O teste de normalidade multivariada √© fundamental para verificar se os dados seguem uma distribui√ß√£o normal multivariada, pressuposto da an√°lise discriminante linear. Testamos cada um dos tr√™s grupos separadamente usando o teste de Henze-Zirkler.


```{r}
library(MVN)

# Armazenar resultados dos testes de normalidade
resultados_normalidade <- list()

for(grupo in levels(amostra_analise$X1)) {
  dados_grupo <- amostra_analise[amostra_analise$X1 == grupo, variaveis_independentes]
  
  # Usando par√¢metros corretos da fun√ß√£o mvn
  resultado_mvn <- mvn(dados_grupo, mvn_test = "hz", univariate_test = "SW")
  resultados_normalidade[[grupo]] <- resultado_mvn$multivariate_normality
  
  # Teste alternativo se o primeiro falhar
  if(is.null(resultado_mvn$multivariate_normality)) {
    resultado_mardia <- mvn(dados_grupo, mvn_test = "mardia")
    resultados_normalidade[[grupo]] <- resultado_mardia$multivariate_normality
  }
}

# Mostrar resultados
print(resultados_normalidade)
```

**Resumo dos Testes de Normalidade:**

Com base nos resultados obtidos, 2 dos 3 grupos atendem ao pressuposto de normalidade multivariada ao n√≠vel de signific√¢ncia de 5%. O grupo que apresentou desvio (p = 0.035) est√° pr√≥ximo do limite aceit√°vel, e a an√°lise discriminante pode prosseguir com confian√ßa.

#### 3.2 Homogeneidade das Matrizes de Covari√¢ncia

O teste M de Box verifica se as matrizes de covari√¢ncia dos grupos s√£o homog√™neas, outro pressuposto importante da an√°lise discriminante. Este teste avalia se as 13 vari√°veis independentes apresentam estruturas de covari√¢ncia similares entre os grupos.

**Interpreta√ß√£o dos Resultados do Teste M de Box:**

**Conclus√£o**: Com p-valor = 0.01122 < 0.05, rejeitamos a hip√≥tese nula de homogeneidade das matrizes de covari√¢ncia. Isso indica que **h√° diferen√ßas significativas** entre as estruturas de covari√¢ncia dos grupos.

**Implica√ß√µes Pr√°ticas:**
- A viola√ß√£o da homogeneidade das covari√¢ncias sugere que a **An√°lise Discriminante Quadr√°tica (QDA)** poderia ser mais apropriada que a Linear (LDA)
- No entanto, a LDA √© robusta a viola√ß√µes moderadas deste pressuposto, especialmente quando os tamanhos das amostras s√£o similares
- Como os grupos est√£o relativamente balanceados (conforme mostrado acima), podemos prosseguir com cautela usando LDA
- Os resultados devem ser interpretados considerando esta limita√ß√£o

```{r}
library(biotools)

dados_teste <- amostra_analise[, variaveis_independentes]
grupos_teste <- amostra_analise$X1

# Teste M de Box com tratamento de erro
tryCatch({
  teste_box <- boxM(dados_teste, grupos_teste)
  print(teste_box)
}, error = function(e) {
  message("Teste M de Box n√£o p√¥de ser executado: ", e$message)
  
  for(grupo in levels(amostra_analise$X1)) {
    dados_grupo <- amostra_analise[amostra_analise$X1 == grupo, variaveis_independentes]
    cov_grupo <- cov(dados_grupo)
    message("\nMatriz de Covari√¢ncia - Grupo: ", grupo)
    print(round(cov_grupo, 3))
  }
})
```

#### 3.3 Multicolinearidade

A presen√ßa de multicolinearidade pode afetar a estabilidade dos resultados da an√°lise discriminante. O determinante da matriz de correla√ß√£o e os valores VIF nos ajudam a identificar poss√≠veis problemas de multicolinearidade entre as vari√°veis.

**Interpreta√ß√£o dos Valores VIF:**

Os Fatores de Infla√ß√£o da Vari√¢ncia (VIF) revelam problemas significativos de multicolinearidade:

- **VIF < 5**: Multicolinearidade baixa (aceit√°vel)
  - X6 (1.90), X7 (4.56), X8 (4.71), X10 (1.65), X13 (1.76), X14 (4.16), X15 (1.23), X16 (4.33)

- **VIF entre 5-10**: Multicolinearidade moderada (preocupante)
  - X9 (5.33), X12 (5.78)

- **VIF > 10**: Multicolinearidade alta (problem√°tica)
  - **X11 (Product Line)**: VIF = 52.77
  - **X17 (Price Flexibility)**: VIF = 41.49  
  - **X18 (Delivery Speed)**: VIF = 56.34

**Implica√ß√µes:**
- As vari√°veis X11, X17 e X18 apresentam alta correla√ß√£o com outras vari√°veis independentes
- Isso pode causar instabilidade nos coeficientes discriminantes
- O determinante da matriz de correla√ß√£o confirma a presen√ßa de multicolinearidade
- Apesar disso, seguimos o exemplo de Hair et al. usando X6 e X18, reconhecendo esta limita√ß√£o

```{r}
# Matriz de correla√ß√£o com visualiza√ß√£o aprimorada
matriz_cor <- cor(amostra_analise[, variaveis_independentes])

# Gr√°fico de correla√ß√£o personalizado
corrplot::corrplot(matriz_cor, method = "color", type = "upper", 
                   order = "hclust", tl.cex = 0.8, tl.col = "black",
                   col = RColorBrewer::brewer.pal(n = 8, name = "RdYlBu"),
                   title = "Matriz de Correla√ß√£o das Vari√°veis Independentes",
                   mar = c(0,0,2,0))

# Determinante da matriz de correla√ß√£o
det_cor <- det(matriz_cor)

# VIF para identificar multicolinearidade
modelo_temp <- lm(as.numeric(X1) ~ ., data = amostra_analise[, c("X1", variaveis_independentes)])
vif_valores <- car::vif(modelo_temp)
```

**An√°lise de Multicolinearidade:**

- **Determinante da matriz de correla√ß√£o**: `r round(det_cor, 6)`

**Classifica√ß√£o dos Valores VIF:**

| Categoria | Crit√©rio | Vari√°veis |
|-----------|----------|-----------|
| **Baixa** (< 5) | Aceit√°vel | `r paste(names(vif_valores[vif_valores < 5]), collapse = ", ")` |
| **Moderada** (5-10) | Preocupante | `r paste(names(vif_valores[vif_valores >= 5 & vif_valores < 10]), collapse = ", ")` |
| **Alta** (‚â• 10) | Problem√°tica | `r paste(names(vif_valores[vif_valores >= 10]), collapse = ", ")` |

**Vari√°veis com Multicolinearidade Severa:**
```{r}
#| echo: false
vif_altos <- vif_valores[vif_valores >= 10]
knitr::kable(data.frame(
  Vari√°vel = names(vif_altos),
  Descri√ß√£o = sapply(names(vif_altos), obter_descricao),
  VIF = round(vif_altos, 2)
), row.names = FALSE)
```

### Est√°gio 4: Estima√ß√£o do Modelo Discriminante e Avalia√ß√£o do Ajuste Geral

#### 4.1 M√©todo Stepwise

```{r}
library(klaR)
library(MASS)

# Implementando stepwise manual baseado em crit√©rios estat√≠sticos
f_univariados <- numeric(length(variaveis_independentes))
p_univariados <- numeric(length(variaveis_independentes))
names(f_univariados) <- variaveis_independentes
names(p_univariados) <- variaveis_independentes

for(i in seq_along(variaveis_independentes)) {
  var <- variaveis_independentes[i]
  formula_temp <- as.formula(paste(var, "~ X1"))
  
  tryCatch({
    anova_temp <- aov(formula_temp, data = amostra_analise)
    anova_summary <- summary(anova_temp)
    f_univariados[i] <- anova_summary[[1]]["X1", "F value"]
    p_univariados[i] <- anova_summary[[1]]["X1", "Pr(>F)"]
  }, error = function(e) {
    f_univariados[i] <- 0
    p_univariados[i] <- 1
  })
}

# Ordenando vari√°veis por poder discriminante
ordem_importancia <- order(f_univariados, decreasing = TRUE)
vars_ordenadas <- variaveis_independentes[ordem_importancia]
vars_significativas <- names(p_univariados[p_univariados < 0.05])

# Testando modelo Hair et al.: X6 + X18
formula_hair <- as.formula("cbind(X6, X18) ~ X1")
manova_hair <- manova(formula_hair, data = amostra_analise)
resultado_hair <- summary(manova_hair, test = "Wilks")

modelo_stepwise <- list(
  formula = "X1 ~ X6 + X18",
  selected_vars = c("X6", "X18"),
  wilks_lambda = resultado_hair$stats["X1", "Wilks"],
  f_statistic = resultado_hair$stats["X1", "approx F"],
  p_value = resultado_hair$stats["X1", "Pr(>F)"]
)
```

**An√°lise Univariada de Vari√°veis:**

**Ranking por Poder Discriminante (Top 5):**
```{r}
#| echo: false
top5 <- data.frame(
  Posi√ß√£o = 1:5,
  Vari√°vel = vars_ordenadas[1:5],
  Descri√ß√£o = sapply(vars_ordenadas[1:5], obter_descricao),
  `F-value` = round(f_univariados[vars_ordenadas[1:5]], 3),
  `p-valor` = round(p_univariados[vars_ordenadas[1:5]], 4),
  Signific√¢ncia = ifelse(p_univariados[vars_ordenadas[1:5]] < 0.001, "***",
                        ifelse(p_univariados[vars_ordenadas[1:5]] < 0.01, "**",
                              ifelse(p_univariados[vars_ordenadas[1:5]] < 0.05, "*", "")))
)
knitr::kable(top5, row.names = FALSE)
```

**Modelo Stepwise Final:**

- **F√≥rmula selecionada**: `r modelo_stepwise$formula`
- **Vari√°veis inclu√≠das**: `r paste(modelo_stepwise$selected_vars, collapse = " + ")`
- **Lambda de Wilks**: `r round(modelo_stepwise$wilks_lambda, 4)`
- **Estat√≠stica F**: `r round(modelo_stepwise$f_statistic, 3)`
- **p-valor**: `r formatC(modelo_stepwise$p_value, format = "e", digits = 3)`
- **Total de vari√°veis significativas**: `r length(vars_significativas)` de `r length(variaveis_independentes)`

**Justificativa da Sele√ß√£o:**
Embora `r vars_ordenadas[1]` seja a vari√°vel mais discriminante univariadamente, seguimos o exemplo de Hair et al. usando X6 (Product Quality) + X18 (Delivery Speed) por raz√µes te√≥ricas e interpretabilidade gerencial.

#### 4.2 An√°lise Discriminante Linear

```{r}
# Modelo final conforme Hair et al. (X6 e X18)
modelo_final <- lda(X1 ~ X6 + X18, data = amostra_analise)

# Autovalores e vari√¢ncia explicada
eigenvalues <- modelo_final$svd^2
variancia_explicada <- eigenvalues / sum(eigenvalues) * 100
```

O modelo discriminante final utiliza as vari√°veis X6 (Product Quality) e X18 (Delivery Speed), seguindo o exemplo de Hair et al.

**Caracter√≠sticas do Modelo:**

- **N√∫mero de fun√ß√µes discriminantes**: `r length(eigenvalues)`
- **Vari√¢ncia explicada pela Fun√ß√£o 1**: `r round(variancia_explicada[1], 1)`%
- **Vari√¢ncia explicada pela Fun√ß√£o 2**: `r round(variancia_explicada[2], 1)`%
- **Vari√¢ncia total explicada**: `r round(sum(variancia_explicada), 1)`%

**Autovalores:**
```{r}
#| echo: false
knitr::kable(data.frame(
  Fun√ß√£o = paste("LD", 1:length(eigenvalues)),
  Autovalor = round(eigenvalues, 4),
  `Vari√¢ncia Explicada (%)` = round(variancia_explicada, 1)
), row.names = FALSE)
```

#### 4.3 Signific√¢ncia Estat√≠stica

O teste de signific√¢ncia avalia se o modelo discriminante √© estatisticamente significativo.

```{r}
modelo_manova <- manova(cbind(X6, X18) ~ X1, data = amostra_analise)
summary(modelo_manova, test = "Wilks")

summary.aov(modelo_manova)
```

**Interpreta√ß√£o dos Resultados de Signific√¢ncia:**

**Teste MANOVA (Multivariado):**
- **Lambda de Wilks = 0.29005**: Valor baixo indica boa discrimina√ß√£o entre grupos
- **F aproximado = 23.99**: Estat√≠stica F alta sugere diferen√ßas significativas
- **p-valor = 2.388e-14**: Altamente significativo (p < 0.001)
- **Conclus√£o**: O modelo discriminante √© estatisticamente significativo

**An√°lises Univariadas por Vari√°vel:**

**X6 (Product Quality):**
- **F = 22.885**: Alta capacidade discriminante individual
- **p-valor = 5.062e-08**: Altamente significativo
- **Interpreta√ß√£o**: A qualidade do produto varia significativamente entre os grupos de tempo de relacionamento

**X18 (Delivery Speed):**
- **F = 24.425**: Maior capacidade discriminante individual entre as duas vari√°veis
- **p-valor = 2.182e-08**: Altamente significativo  
- **Interpreta√ß√£o**: A percep√ß√£o da velocidade de entrega √© o melhor discriminador individual entre os grupos

**Implica√ß√µes Gerenciais:**
1. Ambas as vari√°veis contribuem significativamente para distinguir os grupos
2. Velocidade de entrega (X18) √© ligeiramente mais discriminante que qualidade (X6)
3. O modelo como um todo tem poder discriminante muito forte
4. As percep√ß√µes evoluem significativamente com o tempo de relacionamento

#### 4.4 Centr√≥ides dos Grupos

Os centr√≥ides representam o "centro" de cada grupo no espa√ßo discriminante.

```{r}
centroides <- aggregate(amostra_analise[, c("X6", "X18")], 
                       by = list(amostra_analise$X1), FUN = mean)
names(centroides)[1] <- "Grupo"

predict_centroides <- predict(modelo_final, centroides[, c("X6", "X18")])
centroides_discriminantes <- predict_centroides$x
rownames(centroides_discriminantes) <- centroides$Grupo
print("\nCentr√≥ides no Espa√ßo Discriminante:")
print(centroides_discriminantes)
```

**An√°lise dos Centr√≥ides no Espa√ßo Discriminante:**

**Posicionamento dos Grupos:**

| Grupo | LD1 | LD2 | Interpreta√ß√£o |
|-------|-----|-----|---------------|
| Menos de 1 ano | -1.61 | 0.31 | Percep√ß√µes mais baixas, posicionamento √∫nico |
| De 1 a 5 anos | 0.26 | -0.71 | Percep√ß√µes intermedi√°rias, diferencia√ß√£o moderada |
| Mais de 5 anos | 1.47 | 0.53 | Percep√ß√µes mais elevadas, alta satisfa√ß√£o |

**Padr√µes Identificados:**

1. **Evolu√ß√£o Linear em LD1**: Os valores de LD1 crescem progressivamente (-1.61 ‚Üí 0.26 ‚Üí 1.47), indicando melhoria das percep√ß√µes com o tempo de relacionamento

2. **Separa√ß√£o Clara**: A dist√¢ncia entre centr√≥ides confirma que os grupos s√£o bem diferenciados no espa√ßo discriminante

3. **Trajet√≥ria de Relacionamento**: 
   - **Clientes novos** (< 1 ano): Expectativas em forma√ß√£o, percep√ß√µes iniciais mais cr√≠ticas
   - **Clientes intermedi√°rios** (1-5 anos): Per√≠odo de consolida√ß√£o das percep√ß√µes
   - **Clientes estabelecidos** (> 5 anos): Relacionamento maduro, percep√ß√µes mais positivas

**Interpreta√ß√£o das Fun√ß√µes Discriminantes:**

- **LD1**: Representa principalmente a **evolu√ß√£o temporal** das percep√ß√µes (experi√™ncia acumulada)
- **LD2**: Representa **diferen√ßas qualitativas** espec√≠ficas entre os grupos intermedi√°rios e extremos

**Implica√ß√µes Estrat√©gicas:**
- Foco na **reten√ß√£o inicial**: Clientes novos precisam de aten√ß√£o especial
- **Gest√£o da jornada**: Processo gradual de melhoria das percep√ß√µes
- **Fideliza√ß√£o**: Clientes de longo prazo s√£o verdadeiros advogados da marca

### Est√°gio 5: Interpreta√ß√£o dos Resultados

#### 5.1 Cargas Discriminantes (Matriz Estrutural)

As cargas discriminantes mostram a correla√ß√£o entre cada vari√°vel independente e as fun√ß√µes discriminantes.

```{r}
# Calculando cargas discriminantes (correla√ß√µes entre vari√°veis e fun√ß√µes)
# Escores discriminantes para todas as observa√ß√µes
escores_discriminantes <- predict(modelo_final, amostra_analise)$x

# Matriz de cargas (correla√ß√µes)
variaveis_completas <- amostra_analise[, variaveis_independentes]
cargas_discriminantes <- cor(variaveis_completas, escores_discriminantes)

print("Matriz de Cargas Discriminantes (n√£o-rotacionadas):")
print(round(cargas_discriminantes, 3))

# Identificando vari√°veis descritivas (|carga| >= 0.40)
cargas_importantes <- abs(cargas_discriminantes) >= 0.40
print("\nVari√°veis Descritivas por Fun√ß√£o (|carga| >= 0.40):")
for(i in 1:ncol(cargas_discriminantes)) {
  cat("Fun√ß√£o", i, ":", names(which(cargas_importantes[, i])), "\n")
}
```

**Interpreta√ß√£o da Matriz de Cargas Discriminantes:**

**An√°lise da Fun√ß√£o Discriminante 1 (LD1):**

**Vari√°veis com Cargas Altas (|carga| ‚â• 0.40):**
- **X11 (Product Line)**: 0.773 - Maior contribui√ß√£o para LD1
- **X18 (Delivery Speed)**: 0.765 - Forte correla√ß√£o positiva
- **X6 (Product Quality)**: 0.736 - Alta correla√ß√£o positiva  
- **X9 (Complaint Resolution)**: 0.728 - Contribui√ß√£o significativa
- **X16 (Ordering & Billing)**: 0.699 - Forte correla√ß√£o

**Interpreta√ß√£o de LD1**: Representa a **dimens√£o geral de satisfa√ß√£o** com aspectos operacionais e de qualidade da HBAT. Valores altos indicam percep√ß√µes positivas em qualidade, entrega, linha de produtos e resolu√ß√£o de problemas.

**An√°lise da Fun√ß√£o Discriminante 2 (LD2):**

**Vari√°veis com Cargas Altas (|carga| ‚â• 0.40):**
- **X17 (Price Flexibility)**: -0.699 - Maior magnitude (negativa)
- **X6 (Product Quality)**: 0.677 - Correla√ß√£o positiva forte
- **X18 (Delivery Speed)**: -0.644 - Correla√ß√£o negativa significativa
- **X9 (Complaint Resolution)**: -0.467 - Contribui√ß√£o moderada negativa
- **X16 (Ordering & Billing)**: -0.416 - Correla√ß√£o negativa
- **X12 (Salesforce Image)**: -0.418 - Contribui√ß√£o moderada negativa

**Interpreta√ß√£o de LD2**: Representa um **contraste entre qualidade percebida** versus **flexibilidade operacional**. Separa grupos com diferentes prioridades: qualidade versus agilidade/flexibilidade.

#### 5.2 Rota√ß√£o VARIMAX

```{r}
# Aplicando rota√ß√£o VARIMAX √†s cargas discriminantes
library(stats)

if(ncol(cargas_discriminantes) > 1) {
  rotacao_varimax <- varimax(cargas_discriminantes)
  cargas_rotacionadas <- rotacao_varimax$loadings[]
  
  print("Matriz de Cargas Discriminantes (rotacionadas - VARIMAX):")
  print(round(cargas_rotacionadas, 3))
  
  # Vari√°veis descritivas ap√≥s rota√ß√£o
  cargas_rot_importantes <- abs(cargas_rotacionadas) >= 0.40
  print("\nVari√°veis Descritivas por Fun√ß√£o Rotacionada (|carga| >= 0.40):")
  for(i in 1:ncol(cargas_rotacionadas)) {
    cat("Fun√ß√£o", i, ":", names(which(cargas_rot_importantes[, i])), "\n")
  }
} else {
  cargas_rotacionadas <- cargas_discriminantes
  print("Apenas uma fun√ß√£o discriminante - rota√ß√£o n√£o aplic√°vel")
}
```

**Interpreta√ß√£o das Cargas Rotacionadas (VARIMAX):**

A rota√ß√£o VARIMAX simplifica a estrutura, criando fatores mais interpret√°veis:

**Fun√ß√£o 1 Rotacionada:**
- **X6 (Product Quality)**: 1.000 - Carga perfeitamente concentrada
- **X11 (Product Line)**: 0.538 - Contribui√ß√£o moderada
- **X17 (Price Flexibility)**: -0.462 - Contribui√ß√£o negativa moderada

**Interpreta√ß√£o**: LD1 rotacionada representa essencialmente a **"Dimens√£o de Qualidade"**, contrastando qualidade percebida com flexibilidade de pre√ßos.

**Fun√ß√£o 2 Rotacionada:**
- **X18 (Delivery Speed)**: -0.992 - Concentra√ß√£o quase perfeita (negativa)
- **X9 (Complaint Resolution)**: -0.836 - Alta correla√ß√£o negativa  
- **X16 (Ordering & Billing)**: -0.779 - Correla√ß√£o negativa forte
- **X11 (Product Line)**: -0.558 - Contribui√ß√£o moderada
- **X17 (Price Flexibility)**: -0.524 - Contribui√ß√£o moderada

**Interpreta√ß√£o**: LD2 rotacionada representa a **"Dimens√£o Operacional"**, focando em velocidade, efici√™ncia e aspectos transacionais.

**Vantagem da Rota√ß√£o:**
- **Simplifica interpreta√ß√£o**: Cada fun√ß√£o tem foco mais claro
- **Reduz ambiguidade**: Menos vari√°veis com cargas altas em m√∫ltiplas fun√ß√µes
- **Facilita comunica√ß√£o gerencial**: Dimens√µes mais intuitivas

#### 5.3 √çndice de Pot√™ncia

```{r}
# Calculando √≠ndice de pot√™ncia conforme Hair et al.
if(ncol(cargas_discriminantes) > 1) {
  # Autovalores relativos
  autovalores_relativos <- eigenvalues / sum(eigenvalues)
  
  # √çndice de pot√™ncia para cada vari√°vel
  indice_potencia <- numeric(nrow(cargas_rotacionadas))
  names(indice_potencia) <- rownames(cargas_rotacionadas)
  
  for(i in 1:nrow(cargas_rotacionadas)) {
    potencia_total <- 0
    for(j in 1:ncol(cargas_rotacionadas)) {
      potencia_total <- potencia_total + (cargas_rotacionadas[i, j]^2 * autovalores_relativos[j])
    }
    indice_potencia[i] <- potencia_total
  }
  
  # Ordenando por √≠ndice de pot√™ncia
  indice_potencia_ordenado <- sort(indice_potencia, decreasing = TRUE)
  
  print("√çndice de Pot√™ncia das Vari√°veis:")
  print(round(indice_potencia_ordenado, 3))
}
```

**Interpreta√ß√£o do √çndice de Pot√™ncia:**

O √≠ndice de pot√™ncia combina a contribui√ß√£o de cada vari√°vel em todas as fun√ß√µes, ponderada pela import√¢ncia relativa de cada fun√ß√£o:

**Ranking por Poder Discriminante Total:**

| Posi√ß√£o | Vari√°vel | Descri√ß√£o | √çndice | Interpreta√ß√£o |
|---------|----------|-----------|--------|---------------|
| 1¬∫ | X6 | Product Quality | 0.835 | **Discriminador principal** - fundamental para diferencia√ß√£o |
| 2¬∫ | X11 | Product Line | 0.293 | **Segundo mais importante** - variedade de produtos relevante |
| 3¬∫ | X17 | Price Flexibility | 0.224 | **Terceiro lugar** - flexibilidade de pre√ßos diferencia grupos |
| 4¬∫ | X18 | Delivery Speed | 0.176 | **Quarto lugar** - velocidade importante apesar de estar no modelo |
| 5¬∫ | X9 | Complaint Resolution | 0.157 | **Moderadamente importante** - resolu√ß√£o de problemas diferencia |

**Insights Principais:**

1. **X6 (Product Quality)** √© o discriminador dominante, respons√°vel por mais de 83% do poder discriminante total
2. **X18 (Delivery Speed)**, apesar de estar no modelo final, ocupa apenas a 4¬™ posi√ß√£o no √≠ndice de pot√™ncia
3. **X11 (Product Line)** aparece como segundo mais importante, sugerindo que variedade de produtos √© crucial
4. A **concentra√ß√£o de poder** nas primeiras vari√°veis indica que poucas dimens√µes explicam a maior parte da discrimina√ß√£o

**Implica√ß√µes Gerenciais:**
- **Prioridade m√°xima**: Investir em qualidade do produto
- **Segunda prioridade**: Expandir e melhorar linha de produtos
- **Terceira prioridade**: Desenvolver flexibilidade de pre√ßos
- **Monitoramento**: Acompanhar velocidade de entrega e resolu√ß√£o de reclama√ß√µes

#### 5.4 Raz√µes F Univariadas

```{r}
# Calculando raz√µes F univariadas para cada vari√°vel
razoes_f <- numeric(length(variaveis_independentes))
names(razoes_f) <- variaveis_independentes

for(var in variaveis_independentes) {
  formula_temp <- as.formula(paste(var, "~ X1"))
  anova_temp <- aov(formula_temp, data = amostra_analise)
  razoes_f[var] <- summary(anova_temp)[[1]]["X1", "F value"]
}

# Ordenando por valor F
razoes_f_ordenadas <- sort(razoes_f, decreasing = TRUE)

print("Raz√µes F Univariadas:")
print(round(razoes_f_ordenadas, 3))

# Teste de signific√¢ncia (Œ± = 0.05)
p_valores <- numeric(length(variaveis_independentes))
names(p_valores) <- variaveis_independentes

for(var in variaveis_independentes) {
  formula_temp <- as.formula(paste(var, "~ X1"))
  anova_temp <- aov(formula_temp, data = amostra_analise)
  p_valores[var] <- summary(anova_temp)[[1]]["X1", "Pr(>F)"]
}

print("\nVari√°veis Significativas (p < 0.05):")
print(names(p_valores[p_valores < 0.05]))
```

**Interpreta√ß√£o das Raz√µes F Univariadas:**

**Ranking de Poder Discriminante Individual:**

| Posi√ß√£o | Vari√°vel | F-value | p-valor | Status | Interpreta√ß√£o |
|---------|----------|---------|---------|--------|---------------|
| 1¬∫ | X18 (Delivery Speed) | 24.425 | < 0.001 | *** | **Melhor discriminador individual** |
| 2¬∫ | X6 (Product Quality) | 22.885 | < 0.001 | *** | **Segundo melhor discriminador** |
| 3¬∫ | X9 (Complaint Resolution) | 22.739 | < 0.001 | *** | **Terceiro em poder discriminante** |
| 4¬∫ | X11 (Product Line) | 20.721 | < 0.001 | *** | **Quarto colocado significativo** |
| 5¬∫ | X16 (Ordering & Billing) | 17.664 | < 0.001 | *** | **Quinto em import√¢ncia** |

**Vari√°veis Significativas (p < 0.05):** X6, X9, X11, X13, X16, X17, X18 (7 de 13 vari√°veis)

**Compara√ß√£o: Poder Individual vs. Poder Combinado:**

1. **X18 (Delivery Speed)**: 
   - Individual: 1¬∫ lugar (F = 24.425)
   - Combinado: 4¬∫ lugar (√çndice = 0.176)
   - **Interpreta√ß√£o**: Excelente discriminador individual, mas com alguma redund√¢ncia no modelo conjunto

2. **X6 (Product Quality)**:
   - Individual: 2¬∫ lugar (F = 22.885)  
   - Combinado: 1¬∫ lugar (√çndice = 0.835)
   - **Interpreta√ß√£o**: Forte individual e dominante no modelo conjunto

**Insights sobre Sele√ß√£o de Vari√°veis:**

- **Crit√©rio Hair et al.**: Usar X6 + X18 √© justificado pelo alto poder discriminante individual de ambas
- **Potencial de otimiza√ß√£o**: X9 (Complaint Resolution) tem poder individual muito alto e poderia ser considerada
- **Redund√¢ncia**: V√°rias vari√°veis significativas sugerem multicolinearidade (confirmada pelos VIF altos)

**Recomenda√ß√µes Gerenciais:**
1. **Foco prim√°rio**: Delivery Speed e Product Quality (vari√°veis do modelo)
2. **Foco secund√°rio**: Complaint Resolution (alto poder discriminante individual)  
3. **Monitoramento**: Product Line e Ordering & Billing (significativas e importantes)
4. **Revis√£o**: Considerar modelo expandido incluindo X9 para melhor discrimina√ß√£o

#### 5.5 Gr√°fico de Vetores de Atribui√ß√£o no Espa√ßo Discriminante

```{r}
# Gr√°fico dos valores F univariados com descri√ß√µes
f_df <- data.frame(
  Variavel = names(f_univariados),
  F_Value = f_univariados,
  P_Value = p_univariados,
  Significativo = p_univariados < 0.05
) %>%
  dplyr::mutate(Variavel_Desc = sapply(Variavel, obter_descricao))

p_f_values <- ggplot2::ggplot(f_df, ggplot2::aes(x = reorder(Variavel_Desc, F_Value), 
                                                 y = F_Value, fill = Significativo)) +
  ggplot2::geom_col(alpha = 0.8) +
  ggplot2::geom_text(ggplot2::aes(label = round(F_Value, 1)), hjust = -0.1, size = 3) +
  ggplot2::coord_flip() +
  ggplot2::scale_fill_manual(values = c("TRUE" = "steelblue", "FALSE" = "gray70"),
                            labels = c("FALSE" = "N√£o Significativo", "TRUE" = "Significativo")) +
  ggplot2::labs(title = "Valores F Univariados para Sele√ß√£o de Vari√°veis",
                subtitle = "Poder discriminante individual de cada vari√°vel",
                x = "Vari√°veis", y = "Estat√≠stica F",
                fill = "Signific√¢ncia\n(p < 0.05)") +
  ggplot2::theme_minimal() +
  ggplot2::theme(plot.title = ggplot2::element_text(size = 14, face = "bold"),
                 axis.text.y = ggplot2::element_text(size = 9))

print(p_f_values)

# Criando gr√°fico de vetores de atribui√ß√£o (vari√°veis no espa√ßo discriminante)
escores_todos <- predict(modelo_final, amostra_analise)$x
df_escores <- data.frame(
  Funcao1 = escores_todos[, 1],
  Funcao2 = escores_todos[, 2],
  Grupo = amostra_analise$X1,
  Probabilidades = apply(predict(modelo_final, amostra_analise)$posterior, 1, max)
)

# Adicionando centr√≥ides
df_centroides <- data.frame(
  Funcao1 = centroides_discriminantes[, 1],
  Funcao2 = centroides_discriminantes[, 2],
  Grupo = factor(rownames(centroides_discriminantes), 
                levels = levels(amostra_analise$X1))
)

# Escalonando as cargas para melhor visualiza√ß√£o
escala_vetor <- 3  # Fator de escala para os vetores
cargas_escalonadas <- cargas_discriminantes * escala_vetor

# Preparando dados dos vetores com descri√ß√µes
vetores_df <- data.frame(
  Variavel = rownames(cargas_discriminantes),
  LD1_start = 0,
  LD2_start = 0,
  LD1_end = cargas_escalonadas[, 1],
  LD2_end = cargas_escalonadas[, 2],
  Magnitude = sqrt(cargas_discriminantes[, 1]^2 + cargas_discriminantes[, 2]^2),
  Significativa = rownames(cargas_discriminantes) %in% vars_significativas
) %>%
  dplyr::mutate(Variavel_Desc = sapply(Variavel, obter_descricao))

# Gr√°fico de vetores de atribui√ß√£o expandidos
p_vetores <- ggplot2::ggplot() +
  # Pontos dos grupos (mais transparentes para n√£o ofuscar os vetores)
  ggplot2::geom_point(data = df_escores, ggplot2::aes(x = Funcao1, y = Funcao2, color = Grupo), 
                      alpha = 0.3, size = 1) +
  # Centr√≥ides dos grupos
  ggplot2::geom_point(data = df_centroides, ggplot2::aes(x = Funcao1, y = Funcao2), 
                      size = 6, shape = 17, color = "black") +
  # LABELS DOS CENTR√ìIDES - NOVO
  ggplot2::geom_text(data = df_centroides, 
                     ggplot2::aes(x = Funcao1, y = Funcao2, label = Grupo),
                     vjust = -1.5, hjust = 0.5, color = "black", 
                     fontface = "bold", size = 3.5,
                     box.padding = 0.5) +
  # Vetores das vari√°veis
  ggplot2::geom_segment(data = vetores_df,
                        ggplot2::aes(x = LD1_start, y = LD2_start, 
                                     xend = LD1_end, yend = LD2_end,
                                     color = Significativa, size = Magnitude),
                        arrow = ggplot2::arrow(length = ggplot2::unit(0.3, "cm")),
                        alpha = 0.8) +
  # Labels das vari√°veis com descri√ß√µes
  ggplot2::geom_text(data = vetores_df,
                     ggplot2::aes(x = LD1_end * 1.1, y = LD2_end * 1.1, 
                                  label = Variavel_Desc, color = Significativa),
                     size = 2.5, fontface = "bold") +
  # Eixos de refer√™ncia
  ggplot2::geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
  ggplot2::geom_vline(xintercept = 0, linetype = "dashed", alpha = 0.5) +
  # Escalas e temas
  ggplot2::scale_color_manual(values = c("FALSE" = "gray50", "TRUE" = "red")) +
  ggplot2::scale_size_continuous(range = c(0.5, 2), guide = "none") +
  ggplot2::labs(title = "Vetores de Atribui√ß√£o das Vari√°veis no Espa√ßo Discriminante",
                subtitle = paste("Vetores mostram contribui√ß√£o das vari√°veis para as fun√ß√µes discriminantes\n",
                                "Tri√¢ngulos pretos = centr√≥ides dos grupos | Escala dos vetores: ", escala_vetor, "x"),
                x = paste("Fun√ß√£o Discriminante 1 (", round(variancia_explicada[1], 1), "%)"),
                y = paste("Fun√ß√£o Discriminante 2 (", round(variancia_explicada[2], 1), "%)"),
                color = "Vari√°vel\nSignificativa") +
  ggplot2::theme_minimal() +
  ggplot2::theme(legend.position = "bottom",
                 plot.title = ggplot2::element_text(size = 14, face = "bold"),
                 plot.subtitle = ggplot2::element_text(size = 10))

print(p_vetores)

# IDENTIFICA√á√ÉO DOS GRUPOS DA VARI√ÅVEL DEPENDENTE
cat("\n=== IDENTIFICA√á√ÉO DOS GRUPOS DA VARI√ÅVEL DEPENDENTE ===\n")
cat("Vari√°vel Dependente: X1 (Customer Type)\n")
cat("Descri√ß√£o: Tempo de relacionamento com a empresa HBAT\n\n")

# Grupos identificados no gr√°fico
grupos_identificados <- levels(amostra_analise$X1)
freq_grupos <- table(amostra_analise$X1)
centroides_info <- centroides_discriminantes

cat("GRUPOS REPRESENTADOS NO GR√ÅFICO:\n")
for(i in 1:length(grupos_identificados)) {
  grupo_nome <- grupos_identificados[i]
  freq <- freq_grupos[i]
  ld1_pos <- round(centroides_info[grupo_nome, "LD1"], 2)
  ld2_pos <- round(centroides_info[grupo_nome, "LD2"], 2)
  
  cat(sprintf("üî∫ GRUPO %d: %s\n", i, grupo_nome))
  cat(sprintf("   - Frequ√™ncia: %d casos (%.1f%%)\n", 
              freq, (freq/sum(freq_grupos))*100))
  cat(sprintf("   - Posi√ß√£o no gr√°fico: LD1 = %.2f, LD2 = %.2f\n", ld1_pos, ld2_pos))
  cat(sprintf("   - Caracter√≠stica: %s\n", 
              switch(i,
                     "Clientes com relacionamento recente - percep√ß√µes iniciais",
                     "Clientes com relacionamento estabelecido - percep√ß√µes moderadas", 
                     "Clientes com relacionamento consolidado - percep√ß√µes elevadas")))
  cat("\n")
}

# Interpreta√ß√£o dos centr√≥ides no espa√ßo discriminante
cat("INTERPRETA√á√ÉO DOS CENTR√ìIDES (TRI√ÇNGULOS PRETOS):\n")
cat("- Os tri√¢ngulos pretos representam o 'centro' de cada grupo no espa√ßo discriminante\n")
cat("- Sua posi√ß√£o indica as caracter√≠sticas m√©dias de cada grupo\n")
cat("- A dist√¢ncia entre centr√≥ides mostra o grau de separa√ß√£o entre grupos\n")

# An√°lise das posi√ß√µes dos centr√≥ides
cat("\nAN√ÅLISE DAS POSI√á√ïES:\n")
for(i in 1:nrow(centroides_info)) {
  grupo_nome <- rownames(centroides_info)[i]
  ld1_val <- centroides_info[i, "LD1"]
  ld2_val <- centroides_info[i, "LD2"]
  
  # Interpreta√ß√£o baseada na posi√ß√£o
  interpretacao_ld1 <- ifelse(ld1_val > 0, "valores altos em LD1", "valores baixos em LD1")
  interpretacao_ld2 <- ifelse(ld2_val > 0, "valores altos em LD2", "valores baixos em LD2")
  
  cat(sprintf("- %s: Caracterizado por %s e %s\n", 
              grupo_nome, interpretacao_ld1, interpretacao_ld2))
}

cat("\nLEGENDA DO GR√ÅFICO:\n")
cat("üî∫ Tri√¢ngulos pretos = Centr√≥ides dos grupos\n")
cat("‚óè Pontos coloridos = Observa√ß√µes individuais por grupo\n")
cat("‚Üí Vetores vermelhos = Vari√°veis significativas (p < 0.05)\n")
cat("‚Üí Vetores cinza = Vari√°veis n√£o significativas\n")
cat("üìè Comprimento do vetor = Magnitude da contribui√ß√£o discriminante\n")

# Interpreta√ß√£o dos vetores
cat("\n=== INTERPRETA√á√ÉO DOS VETORES DE ATRIBUI√á√ÉO ===\n")
```

#### 6.4 An√°lise das Dist√¢ncias entre Grupos

```{r}
# Calculando dist√¢ncias Mahalanobis entre centr√≥ides
centroides_matriz <- as.matrix(centroides_discriminantes)

# Matriz de dist√¢ncias entre centr√≥ides
n_grupos <- nrow(centroides_matriz)
dist_centroides <- matrix(0, n_grupos, n_grupos)
rownames(dist_centroides) <- rownames(centroides_matriz)
colnames(dist_centroides) <- rownames(centroides_matriz)

for(i in 1:n_grupos) {
  for(j in 1:n_grupos) {
    dist_centroides[i, j] <- sqrt(sum((centroides_matriz[i, ] - centroides_matriz[j, ])^2))
  }
}

print("Matriz de Dist√¢ncias Euclidianas entre Centr√≥ides:")
print(round(dist_centroides, 3))

# Visualiza√ß√£o das dist√¢ncias como heatmap
dist_df <- reshape2::melt(dist_centroides)
names(dist_df) <- c("Grupo1", "Grupo2", "Distancia")

p_distancias <- ggplot2::ggplot(dist_df, ggplot2::aes(x = Grupo1, y = Grupo2, fill = Distancia)) +
  ggplot2::geom_tile(color = "white") +
  ggplot2::geom_text(ggplot2::aes(label = round(Distancia, 2)), 
                     color = "white", fontface = "bold", size = 5) +
  ggplot2::scale_fill_viridis_c(name = "Dist√¢ncia\nEuclidiana") +
  ggplot2::labs(title = "Matriz de Dist√¢ncias entre Centr√≥ides dos Grupos",
                subtitle = "Dist√¢ncias calculadas no espa√ßo discriminante",
                x = "Grupo", y = "Grupo") +
  ggplot2::theme_minimal() +
  ggplot2::theme(plot.title = ggplot2::element_text(size = 14, face = "bold"),
                 axis.text.x = ggplot2::element_text(angle = 45, hjust = 1))

print(p_distancias)

# An√°lise de separa√ß√£o
dist_matrix_upper <- dist_centroides[upper.tri(dist_centroides)]

# Identificando grupos mais pr√≥ximos e mais distantes
dist_indices <- which(dist_centroides == min(dist_matrix_upper), arr.ind = TRUE)[1, ]
grupos_proximos <- c(rownames(dist_centroides)[dist_indices[1]], 
                    colnames(dist_centroides)[dist_indices[2]])

dist_indices_max <- which(dist_centroides == max(dist_matrix_upper), arr.ind = TRUE)[1, ]
grupos_distantes <- c(rownames(dist_centroides)[dist_indices_max[1]], 
                     colnames(dist_centroides)[dist_indices_max[2]])
```

**Interpreta√ß√£o da An√°lise de Dist√¢ncias:**

**Matriz de Dist√¢ncias Euclidianas:**
- **Menor dist√¢ncia**: "De 1 a 5 anos" ‚Üî "Mais de 5 anos" (1.737)
- **Maior dist√¢ncia**: "Menos de 1 ano" ‚Üî "Mais de 5 anos" (3.084)
- **Dist√¢ncia intermedi√°ria**: "Menos de 1 ano" ‚Üî "De 1 a 5 anos" (2.127)

**Padr√µes de Similaridade:**

1. **Grupos Intermedi√°rio e Maduro s√£o mais pr√≥ximos**: 
   - Dist√¢ncia de apenas 1.737 unidades
   - **Interpreta√ß√£o**: Ap√≥s 1 ano, as percep√ß√µes come√ßam a convergir
   - **Implica√ß√£o**: O primeiro ano √© cr√≠tico para formar percep√ß√µes duradouras

2. **Clientes Novos s√£o mais distantes de todos**:
   - Maior dist√¢ncia dos clientes maduros (3.084)
   - **Interpreta√ß√£o**: Per√≠odo inicial tem caracter√≠sticas muito distintas
   - **Implica√ß√£o**: Estrat√©gias espec√≠ficas necess√°rias para novos clientes

3. **Progress√£o N√£o-Linear**:
   - A evolu√ß√£o "Novo ‚Üí Intermedi√°rio ‚Üí Maduro" n√£o √© uniforme
   - Maior salto entre "Novo" e "Intermedi√°rio" (2.127)
   - Menor progress√£o entre "Intermedi√°rio" e "Maduro" (1.737)

**Insights Gerenciais:**

- **Per√≠odo Cr√≠tico**: Os primeiros 12 meses s√£o fundamentais para reten√ß√£o
- **Converg√™ncia**: Ap√≥s 1 ano, clientes tendem a desenvolver percep√ß√µes similares
- **Segmenta√ß√£o**: Dois grandes segmentos emergem: "Novos" vs. "Estabelecidos" (intermedi√°rios + maduros)

#### 6.5 Compara√ß√£o Visual: Espa√ßo Original vs. Espa√ßo Discriminante

```{r}
# Comparando visualiza√ß√£o no espa√ßo original (X6, X18) vs. espa√ßo discriminante
p_original <- ggplot2::ggplot(amostra_analise, ggplot2::aes(x = X6, y = X18, color = X1)) +
  ggplot2::geom_point(size = 3, alpha = 0.7) +
  ggplot2::stat_ellipse(level = 0.68, type = "norm", size = 1.2) +
  ggplot2::geom_point(data = centroides, ggplot2::aes(x = X6, y = X18), 
                      size = 8, shape = 17, color = "black") +
  ggplot2::scale_color_brewer(type = "qual", palette = "Set1") +
  ggplot2::labs(title = "Espa√ßo Original",
                subtitle = "Vari√°veis originais do modelo discriminante",
                x = descricoes_variaveis["X6"], 
                y = descricoes_variaveis["X18"],
                color = "Grupo") +
  ggplot2::theme_minimal() +
  ggplot2::theme(legend.position = "bottom",
                 plot.title = ggplot2::element_text(size = 12, face = "bold"))

p_discriminante <- ggplot2::ggplot(df_escores, ggplot2::aes(x = Funcao1, y = Funcao2, color = Grupo)) +
  ggplot2::geom_point(size = 3, alpha = 0.7) +
  ggplot2::stat_ellipse(level = 0.68, type = "norm", size = 1.2) +
  ggplot2::geom_point(data = df_centroides, ggplot2::aes(x = Funcao1, y = Funcao2), 
                      size = 8, shape = 17, color = "black") +
  ggplot2::scale_color_brewer(type = "qual", palette = "Set1") +
  ggplot2::labs(title = "Espa√ßo Discriminante (LD1 vs LD2)",
                subtitle = "Fun√ß√µes discriminantes otimizadas para separa√ß√£o",
                x = paste("LD1 (", round(variancia_explicada[1], 1), "%)"),
                y = paste("LD2 (", round(variancia_explicada[2], 1), "%)"),
                color = "Grupo") +
  ggplot2::theme_minimal() +
  ggplot2::theme(legend.position = "bottom",
                 plot.title = ggplot2::element_text(size = 12, face = "bold"))

# Combinando os gr√°ficos
comparacao <- gridExtra::grid.arrange(
  p_original, p_discriminante, 
  ncol = 2,
  top = grid::textGrob("Compara√ß√£o: Espa√ßo Original vs. Espa√ßo Discriminante", 
                       gp = grid::gpar(fontsize = 16, fontface = "bold"))
)

print(comparacao)

# Interpreta√ß√£o da compara√ß√£o
cat("\n=== INTERPRETA√á√ÉO DA COMPARA√á√ÉO ===\n")
cat("- Espa√ßo Original: mostra sobreposi√ß√£o entre grupos\n")
cat("- Espa√ßo Discriminante: maximiza separa√ß√£o entre grupos\n")
cat("- A transforma√ß√£o discriminante melhora a separabilidade\n")
cat("- LD1 e LD2 s√£o combina√ß√µes lineares que maximizam discrimina√ß√£o\n")
```

### Est√°gio 6: Valida√ß√£o dos Resultados

#### 6.6 Matriz de Classifica√ß√£o e Valida√ß√£o

```{r}
# Classifica√ß√£o da amostra de an√°lise
predicoes_analise <- predict(modelo_final, amostra_analise)
matriz_confusao_analise <- table(Predito = predicoes_analise$class, 
                                Real = amostra_analise$X1)

print("Matriz de Classifica√ß√£o - Amostra de An√°lise:")
print(matriz_confusao_analise)

# Taxa de acerto geral
acerto_geral_analise <- sum(diag(matriz_confusao_analise)) / sum(matriz_confusao_analise)

# Taxa de acerto por grupo
acerto_por_grupo_analise <- diag(matriz_confusao_analise) / rowSums(matriz_confusao_analise)
print("Taxa de Acerto por Grupo (An√°lise):")
print(round(acerto_por_grupo_analise * 100, 1))

# Visualiza√ß√£o da matriz de confus√£o
matriz_conf_df <- as.data.frame(matriz_confusao_analise)
names(matriz_conf_df) <- c("Predito", "Real", "Freq")

p_matriz_conf <- ggplot2::ggplot(matriz_conf_df, ggplot2::aes(x = Real, y = Predito, fill = Freq)) +
  ggplot2::geom_tile(color = "white") +
  ggplot2::geom_text(ggplot2::aes(label = Freq), color = "white", size = 6, fontface = "bold") +
  ggplot2::scale_fill_viridis_c(name = "Frequ√™ncia") +
  ggplot2::labs(title = "Matriz de Confus√£o - Amostra de An√°lise",
                subtitle = paste("Taxa de Acerto Geral:", round(acerto_geral_analise * 100, 1), "%"),
                x = "Grupo Real", y = "Grupo Predito") +
  ggplot2::theme_minimal() +
  ggplot2::theme(plot.title = ggplot2::element_text(size = 14, face = "bold"),
                 axis.text.x = ggplot2::element_text(angle = 45, hjust = 1))

print(p_matriz_conf)
```

**Taxa de Acerto Geral (An√°lise)**: `r round(acerto_geral_analise * 100, 1)`%

**Taxa de Acerto por Grupo (An√°lise)**:
```{r}
#| echo: false
knitr::kable(data.frame(
  Grupo = names(acerto_por_grupo_analise),
  `Taxa de Acerto (%)` = round(acerto_por_grupo_analise * 100, 1)
), row.names = FALSE)
```

#### 6.7 Valida√ß√£o Cruzada

```{r}
# Fun√ß√£o para valida√ß√£o cruzada
validacao_cruzada <- function(dados, formula) {
  n <- nrow(dados)
  predicoes <- character(n)
  
  for(i in 1:n) {
    # Treina modelo sem a observa√ß√£o i
    dados_treino <- dados[-i, ]
    modelo_temp <- MASS::lda(formula, data = dados_treino)
    
    # Prediz a observa√ß√£o i
    predicao_temp <- predict(modelo_temp, dados[i, ])
    predicoes[i] <- as.character(predicao_temp$class)
  }
  
  return(factor(predicoes, levels = levels(dados$X1)))
}

# Aplicando valida√ß√£o cruzada
predicoes_cv <- validacao_cruzada(amostra_analise, X1 ~ X6 + X18)
matriz_confusao_cv <- table(Predito = predicoes_cv, Real = amostra_analise$X1)

print("Matriz de Classifica√ß√£o - Valida√ß√£o Cruzada:")
print(matriz_confusao_cv)

# Taxa de acerto valida√ß√£o cruzada
acerto_geral_cv <- sum(diag(matriz_confusao_cv)) / sum(matriz_confusao_cv)
```

**Taxa de Acerto Geral (Valida√ß√£o Cruzada)**: `r round(acerto_geral_cv * 100, 1)`%

#### 6.8 Valida√ß√£o Externa

```{r}
# Classifica√ß√£o da amostra de valida√ß√£o
predicoes_validacao <- predict(modelo_final, amostra_validacao)
matriz_confusao_validacao <- table(Predito = predicoes_validacao$class, 
                                  Real = amostra_validacao$X1)

print("Matriz de Classifica√ß√£o - Amostra de Valida√ß√£o:")
print(matriz_confusao_validacao)

# Taxa de acerto amostra de valida√ß√£o
acerto_geral_validacao <- sum(diag(matriz_confusao_validacao)) / sum(matriz_confusao_validacao)

# Taxa de acerto por grupo
acerto_por_grupo_validacao <- diag(matriz_confusao_validacao) / rowSums(matriz_confusao_validacao)
print("Taxa de Acerto por Grupo (Valida√ß√£o):")
print(round(acerto_por_grupo_validacao * 100, 1))
```

**Taxa de Acerto Geral (Valida√ß√£o)**: `r round(acerto_geral_validacao * 100, 1)`%

#### 6.9 Crit√©rios de Chance

```{r}
# Calculando crit√©rios de chance
tamanhos_grupos <- table(amostra_analise$X1)
proporcoes_grupos <- tamanhos_grupos / sum(tamanhos_grupos)

# Crit√©rio de chance proporcional
criterio_chance_proporcional <- sum(proporcoes_grupos^2) * 100

# Crit√©rio de chance m√°xima
criterio_chance_maxima <- max(proporcoes_grupos) * 100

# Gr√°fico de compara√ß√£o das taxas de acerto
taxas_acerto <- data.frame(
  Metodo = c("An√°lise", "Valida√ß√£o Cruzada", "Valida√ß√£o Externa", 
             "Crit√©rio Proporcional", "Crit√©rio M√°ximo"),
  Taxa = c(acerto_geral_analise * 100, 
           acerto_geral_cv * 100,
           acerto_geral_validacao * 100,
           criterio_chance_proporcional,
           criterio_chance_maxima),
  Tipo = c("Modelo", "Modelo", "Modelo", "Refer√™ncia", "Refer√™ncia")
)

p_performance <- ggplot2::ggplot(taxas_acerto, ggplot2::aes(x = reorder(Metodo, Taxa), y = Taxa, fill = Tipo)) +
  ggplot2::geom_col(alpha = 0.8, width = 0.7) +
  ggplot2::geom_text(ggplot2::aes(label = paste0(round(Taxa, 1), "%")), 
                     hjust = -0.1, size = 4, fontface = "bold") +
  ggplot2::coord_flip() +
  ggplot2::scale_fill_manual(values = c("Modelo" = "steelblue", "Refer√™ncia" = "coral")) +
  ggplot2::labs(title = "Compara√ß√£o das Taxas de Acerto",
                subtitle = "Modelo vs. Crit√©rios de Chance",
                x = "M√©todo de Valida√ß√£o", 
                y = "Taxa de Acerto (%)",
                fill = "Tipo") +
  ggplot2::theme_minimal() +
  ggplot2::theme(legend.position = "bottom",
                 plot.title = ggplot2::element_text(size = 14, face = "bold"))

print(p_performance)
```

**Crit√©rios de Chance:**

- **Crit√©rio de Chance Proporcional**: `r round(criterio_chance_proporcional, 1)`%
- **Crit√©rio de Chance M√°xima**: `r round(criterio_chance_maxima, 1)`%

**Compara√ß√£o com Resultados Obtidos:**

- Taxa de Acerto An√°lise: `r round(acerto_geral_analise * 100, 1)`% vs Crit√©rio Proporcional: `r round(criterio_chance_proporcional, 1)`%
- Taxa de Acerto Valida√ß√£o Cruzada: `r round(acerto_geral_cv * 100, 1)`% vs Crit√©rio Proporcional: `r round(criterio_chance_proporcional, 1)`%  
- Taxa de Acerto Valida√ß√£o: `r round(acerto_geral_validacao * 100, 1)`% vs Crit√©rio Proporcional: `r round(criterio_chance_proporcional, 1)`%

### Resumo da Interpreta√ß√£o Gerencial

Os resultados da an√°lise discriminante revelam insights importantes sobre a diferencia√ß√£o de clientes baseada no tempo de relacionamento. Com o dataset completo analisado, identificamos que de 13 vari√°veis independentes testadas, apenas 2 foram suficientes para uma discrimina√ß√£o efetiva.

#### Principais Descobertas:

1. **Vari√°veis Discriminantes**: X6 (Product Quality) e X18 (Delivery Speed) s√£o os principais diferenciadores, representando aproximadamente 100% da vari√¢ncia discriminante total.

2. **Precis√£o do Modelo**: O modelo alcan√ßa alta taxa de acertos na amostra de an√°lise, superando significativamente os crit√©rios de chance.

3. **Diferen√ßas entre Grupos**: 
   - **Clientes novos** (< 1 ano): Menores percep√ß√µes de qualidade e velocidade
   - **Clientes intermedi√°rios** (1-5 anos): Percep√ß√µes moderadas
   - **Clientes estabelecidos** (> 5 anos): Maiores percep√ß√µes de qualidade e velocidade

#### Implica√ß√µes Gerenciais:

- **Foco na Qualidade**: Investir na melhoria da qualidade do produto √© fundamental para reter clientes
- **Otimiza√ß√£o de Entregas**: A velocidade de entrega √© um diferencial competitivo cr√≠tico
- **Segmenta√ß√£o**: Os 3 grupos identificados requerem estrat√©gias diferenciadas

```{r}
# M√©dias dos grupos para interpreta√ß√£o
medias_grupos <- aggregate(amostra_analise[, variaveis_independentes], 
                          by = list(amostra_analise$X1), FUN = mean)
names(medias_grupos)[1] <- "Grupo"

# Corrigindo erro na impress√£o das m√©dias dos grupos
medias_grupos_numericas <- medias_grupos[, -1]  # Remove coluna 'Grupo'
rownames(medias_grupos_numericas) <- medias_grupos$Grupo

print("M√©dias dos Grupos nas Vari√°veis Independentes:")
print(round(medias_grupos_numericas, 2))

cat("\n=== INTERPRETA√á√ÉO DAS FUN√á√ïES DISCRIMINANTES ===\n")
cat("Fun√ß√£o 1: Diferencia principalmente entre Grupo 1 e Grupos 2-3\n")
cat("Fun√ß√£o 2: Diferencia principalmente entre Grupo 3 e Grupos 1-2\n")

cat("\n=== VARI√ÅVEIS MAIS IMPORTANTES ===\n")
if(exists("indice_potencia_ordenado")) {
  cat("Por √çndice de Pot√™ncia:\n")
  print(names(indice_potencia_ordenado)[1:min(5, length(indice_potencia_ordenado))])
}

cat("\nPor Raz√£o F Univariada:\n")
print(names(razoes_f_ordenadas)[1:min(5, length(razoes_f_ordenadas))])

cat("\n=== RESUMO FINAL ===\n")
cat("Modelo discriminante final: X1 ~ X6 + X18\n")
cat("Vari√°veis selecionadas:\n")
cat("- X6: Qualidade do produto\n")
cat("- X18: Velocidade de entrega\n")

if(exists("modelo_stepwise")) {
  cat("\nVari√°veis selecionadas pelo procedimento stepwise:\n")
  print(modelo_stepwise$formula)
}

cat("\n=== CONCLUS√ïES GERENCIAIS ===\n")
cat("1. A qualidade do produto (X6) e velocidade de entrega (X18) s√£o os principais diferenciadores entre os grupos de clientes.\n")
cat("2. O modelo consegue discriminar bem entre os tr√™s grupos de tempo de relacionamento.\n")
cat("3. Clientes de longo prazo valorizam mais qualidade e velocidade de entrega.\n")
cat("4. A√ß√µes de melhoria devem focar nestas duas dimens√µes para reter clientes.\n")
```

**An√°lise das M√©dias por Grupo:**

Os resultados mostram um padr√£o claro de evolu√ß√£o das percep√ß√µes com o tempo de relacionamento, com melhorias progressivas nas percep√ß√µes de qualidade e velocidade de entrega conforme aumenta o tempo de relacionamento com a empresa.

### Ap√™ndice: Informa√ß√µes T√©cnicas do Dataset

#### Caracter√≠sticas do Dataset HBAT

```{r}
# Informa√ß√µes sobre o dataset ap√≥s limpeza
cat("=== CARACTER√çSTICAS DO DATASET FINAL ===\n")
cat("Total de observa√ß√µes:", nrow(hbat_clean), "\n")
cat("Vari√°veis independentes analisadas:", length(variaveis_independentes), "\n")
cat("Grupos da vari√°vel dependente:", nlevels(hbat_clean$X1), "\n")

# Distribui√ß√£o dos grupos
dist_grupos <- table(hbat_clean$X1)
prop_grupos <- prop.table(dist_grupos) * 100

cat("\nDistribui√ß√£o dos grupos:\n")
for(i in 1:length(dist_grupos)) {
  cat("- ", names(dist_grupos)[i], ": ", dist_grupos[i], " casos (", 
      round(prop_grupos[i], 1), "%)\n", sep = "")
}
```

#### Qualidade dos Dados

- **Missing values**: Removidos atrav√©s de listwise deletion
- **Balanceamento**: Dataset relativamente balanceado entre os grupos
- **Escala das vari√°veis**: Todas as vari√°veis independentes est√£o na escala de 0-10

```{r}
# Informa√ß√µes detalhadas sobre o dataset HBAT
cat("=== INFORMA√á√ïES DO DATASET HBAT ===\n")
cat("Total de observa√ß√µes:", nrow(hbat_clean), "\n")
cat("Vari√°veis independentes:", length(variaveis_independentes), "\n")
cat("Grupos da vari√°vel dependente:", nlevels(hbat_clean$X1), "\n")

# Descri√ß√£o das vari√°veis (baseado nos labels originais) - ATUALIZADO
cat("\n=== DESCRI√á√ÉO COMPLETA DAS VARI√ÅVEIS ===\n")
for(var in names(descricoes_variaveis)) {
  cat(var, "-", descricoes_variaveis[var], "\n")
}

# Estat√≠sticas descritivas finais
cat("\n=== ESTAT√çSTICAS DESCRITIVAS FINAIS ===\n")
print(summary(hbat_clean))
```

